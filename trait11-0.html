<!DOCTYPE html> 
<html>
 <head> 
  <h2>  Brrowing </h2> 
   
 <style>  
  .font1 {
    font-family: "arial";
    font-size: 0.67em;
    }
  .italic {
    font-style: italic;
    }
         
   p{
    font-family: "arial";
    font-size: 0.82em;
    white-space: wrap;  
     width: 98%;
   }
     
   .borderg {

 padding-right: 10px;
 padding-left: 10px;
     padding-top: 10px;
     padding-bottom: 10px;
     border: 8px solid  #EEEEEE ;
    }
  .border1 {
    padding-right: 10px;
   padding-left: 10px;
   padding-top: 10px;
   padding-bottom: 10px;
   border: 8px solid #F0F8FF;
     
  display: inline-block 
   margin:10px;
   }


border1 {
  padding-right: 10px;
 padding-left: 10px;
 padding-top: 10px;
 padding-bottom: 10px;
 border: 8px solid #F0F8FF;
   
display: inline-block 
 margin:10px;
 }







    td {
    padding-right: 0px;
    padding-left: 0px;
    padding-top: 0px;
    padding-bottom: 0px;
  
    }
   
     


 	box1 {
  box-sizing: content-box;
  border: 1px solid    lightgray;
border-left-width: 3px ;
  font-size: 0.8em;
  display: block ;
  background:  #FFF8DC;
   white-space: wrap; 
  padding-right: 3px;
  padding-up: 5px;
   padding-bottom: 5px;
  }
    
         box2 {
         box-sizing: content-box;
         border: 1px solid    lightgray;
         border-left-width: 3px ;
         font-size: 0.8em;
         display: block ;
       
         white-space: wrap; 
         padding-right: 3px;
         padding-up: 5px;
         padding-bottom: 5px;
         }
        
       
      
     box1_default {
     box-sizing: content-box;
     border: 1px solid    lightgray;
     
     font-size: 0.8em;
     display: block ;
     background:  #FFF8DC;
     white-space: pre-wrap; 
     padding-right: 30px;
     }
    
   
  
 


  pre1 { 
   display: block;
  font-family: monospace; 
   white-space: pre; 
   margin: 0;
 padding: 0;
 
  font-size: 1em;
  }
     
          
    pre_default { 
     display: block; 
     font-family: monospace; 
     white-space: pre; 
     margin: 1em 0; 
   } 
   
  
  
    
  table1 {
  display: block; 
   font-family: "arial";
   font-size: 1em;
   border:8px solid  #F0F8FF;
   background: #FFF8DC;
   width: 91%;
   overflow: visible;   
   overflow-x: auto;
   margin: 0.3px;
   padding-top: 10px ;
   padding-bottom: 10px;
   white-space: nowrap;
  }
            

table2 {
 display: block; 
 font-family: "arial";
 font-size: 1em;
 border: 1.4px solid #EEEEEE;
 background: #FFF8DC;
 width: 91%;
 overflow: visible;   
 overflow-x: auto;
 margin: 0.3px;
 padding-top: 10px ;
 padding-bottom: 10px;
 white-space: nowrap;
}



    
    #mainbutton {
    position: relative;
    bottom: 5px;
    }
    
  .button1 {
   position: relative;
   border:1px solid  #EEEEEE ;
   background:   #EEEEEE;
  top : 18px ;   
    left : 87% ;
  font-size: 0.6em;
   width: 21px;
 
  }
  
.boxbutton1 {
 position: relative;
 border:1px solid  #EEEEEE ;
 background:   #EEEEEE;
top : 18px ;   
  left : 92% ;
font-size: 0.6em;
 width: 21px;
 
}






  </style>
 
          
  <script>
    <!-- #5 py4u -->
  function selectElementContents(el) {
   var body = document.body,
   range, sel;
   if (document.createRange && window.getSelection) {
    range = document.createRange();
    sel = window.getSelection();
    sel.removeAllRanges();
    range.selectNodeContents(el);
    sel.addRange(range);
   }
      document.execCommand("Copy");
  }
   </script>
      
     
           



        

   
   <!-- AliceBlue: #F0F8FF   
    cornsilk : #FFF8DC  
   lightgreen  #CCFFCC   
   lightgray  #EEEEEE  -->
 
   </head> 
 
 <meta name="viewport" content=
 "width=device-width, initial-scale=1.0">
 <meta http-equiv="Content-Type" 
 content="text/html; charset=UTF-8">


  <body>  
 

  
       
  <p>üè≠In real life applications, most of 
  the times we have to pass variable bindings 
  to other functions or assign them to other 
  variable bindings. In this case, we are 
  referencing the original binding; borrow 
  the data of it 
     
  <br><br>   <b> What is Borrowing?</b>   
   <br> <br> Borrow (verb)    <br>
    To receive something with the promise of returning it .  
  
     <br><br>
    <strong>  Shared & Mutable borrowings   </strong>  <br>   
    <br>‚≠êÔ∏è There are two types of Borrowing,   
      <br><br>
  <strong>  1.Shared Borrowing (&T)   </strong>
     A piece of data can be borrowed by a single or  
   multiple users, but data should not be altered.   
   <br> <strong> 2.Mutable Borrowing (&mut T)  </strong>
   A piece of data can be borrowed and altered by a 
  single user, but the data should not be accessible for 
  any other users at that time. 

  </strong>  Rules for borrowings </strong> 
   there are very important rules regarding borrowing, 
   <br><br>
  1.One piece of data can be borrowed <b>either</b> as a shared borrow <b>or  
  </b> as a mutable borrow <b>at a given time. But not both at the same time.</b>
   <br>
  2.Borrowing <b>applies for both copy types and move types. </b>
   <br>
  3.The concept of <b>Liveness ‚Ü¥  </b>   </p>

 <input class="button1"  onclick="
 selectElementContents( 
 document.getElementById('sig1a') );" 
 value="copy">
 
 <table1 id=sig1a>a
 <tr><td>        
 <pre1>
 fn main() {
 let mut a = vec![1, 2, 3];
 let b = &mut a;  //  &mut borrow of `a` starts here
 //  ‚Åù
 // some code     //  ‚Åù
 // some code     //  ‚Åù
 }                  //  &mut borrow of `a` ends here
 
 
 fn main() {
 let mut a = vec![1, 2, 3];
 let b = &mut a;  //  &mut borrow of `a` starts here
 // some code
 
 println!("{:?}", a); // trying to access `a` as a shared borrow, so giving an error
 }                  //  &mut borrow of `a` ends here
 
 
 fn main() {
 let mut a = vec![1, 2, 3];
 {
 let b = &mut a;  //  &mut borrow of `a` starts here
 // any other code
 }                  //  &mut borrow of `a` ends here
 
 println!("{:?}", a); // allow borrowing `a` as a shared borrow
 }      
 </pre1>
 </td></tr>
 </table1>          
 
  <p> üí° Let‚Äôs see how to use shared and mutable borrowings 
 in examples. </p> 
   
 <strong>  Examples for Shared Borrowing  </strong>
   
   <strong>       </strong>
    <p>       </p>
  <input class="button1"  onclick="
    selectElementContents( 
    document.getElementById('sig1b') );" 
    value="copy">
    
  <table1 id=sig1b>
  <tr><td>        
 <pre1>
 fn main() {
 let a = [1, 2, 3];
 let b = &a;
 println!("{:?} {}", a, b[0]); // [1, 2, 3] 1
 }
 
 
 fn main() {
 let a = vec![1, 2, 3];
 let b = get_first_element(&a);
 
 println!("{:?} {}", a, b); // [1, 2, 3] 1
 }
 
 fn get_first_element(a: &Vec<i32>) -> i32 {
 a[0]
 }
 </pre1>
   </td></tr>
   </table1>   
   
  
       <br>
     <strong>  Examples for Mutable Borrowing     </strong>
     <p>       </p>
     <input class="button1"  onclick="
     selectElementContents( 
     document.getElementById('sig1-') );" 
     value="copy">
     
     <table1 id=sig1->
     <tr><td>        
 <pre1>
 fn main() {
 let mut a = [1, 2, 3];
 let b = &mut a;
 b[0] = 4;
 println!("{:?}", b); // [4, 2, 3]
 }
 
 
 fn main() {
 let mut a = [1, 2, 3];
 {
 let b = &mut a;
 b[0] = 4;
 }
 
 println!("{:?}", a); // [4, 2, 3]
 }
 
 
 fn main() {
 let mut a = vec![1, 2, 3];
 let b = change_and_get_first_element(&mut a);
 
 println!("{:?} {}", a, b); // [4, 2, 3] 4
 }
 
 fn change_and_get_first_element(a: &mut Vec<i32>) -> i32 {
 a[0] = 4;
 a[0]
 }
 </pre1>
 </td></tr>
 </table1>  
   
  <h2>  Lifetimes </h2>
  <p>When we are dealing with references, we have 
  to make sure that the referencing data stay alive 
  until we stop using the references.
     <br>  
  Think,
     <br> 
  We have a variable binding, a.
  We are referencing the value of a, from another variable 
  binding x.
  We have to make sure that a lives until we stop using x.
         <br><br>
    </p>

          

           
  <box2>              
      <p>
  üîé Memory management is a form of resource 
  management applied to computer memory. Up 
  until the mid-1990s, the majority of programming 
  languages used Manual Memory Management which 
  requires the programmer to give manual 
  instructions to identify and deallocate unused 
  objects/ garbage. Around 1959 John McCarthy 
  invented Garbage collection(GC), a form of 
  Automatic Memory Management(AMM). It determines 
  kwhat memory is no longer used and frees it 
  automatically instead of relying on the programmer. 
  However Objective-C and Swift provide similar 
  pfunctionality through Automatic Reference Counting(ARC)
 </p>
 </box2>
         
         
         
    
  <p>         
  <br><br>
   <b> What is Lifetime?   </b><br>
  In Rust,
         <br><br>
  A resource can only have one owner at a time. When it goes out of the scope, Rust removes it from the Memory.
  <br>When we want to reuse the same resource, we are referencing it/ borrowing its content.
  <br>When dealing with references, we have to specify lifetime annotations to provide instructions for the compiler to set how long those referenced resources should be alive.
  <br>‚≠ê But because of lifetime annotations make the code more verbose, in order to make common patterns more ergonomic, Rust allows lifetimes to be elided/omitted in fn definitions. In this case, the compiler assigns lifetime annotations implicitly.
      <br><br>
  Lifetime annotations are checked at compile-time. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in run time. This is the major reason for slower compilation times in Rust.
         <br><br> 
  Unlike C and C++, usually, Rust doesn‚Äôt explicitly drop values at all.
  Unlike GC, Rust doesn‚Äôt place deallocation calls where the data is no longer referenced.
  Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.
  Usage           <br>
  Lifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually starts with 'a and follows alphabetic order when we need to add multiple lifetime annotations.
      <br><br>
  When using references,
      <br><br>
  01. On Function Declaration
  Input and output parameters with references should attach lifetimes after the & sign.
  ex. ..(x: &'a str) , ..(x: &'a mut str)
        <br><br>
  After the function name, we should mention that the given lifetimes are generic types.
  ex. fn foo<'a>(..) , fn foo<'a, 'b>(..)
      <br><br>
  
     
    
    </p>
   
  
 
     <strong>       </strong>
     <p>       </p>
     <input class="button1"  onclick="
     selectElementContents( 
     document.getElementById('sig1-') );" 
     value="copy">
     
     <table1 id=sig1->
     <tr><td>        
 <pre1>
     
     
 </pre1>
     </td></tr>
     </table1>  
    
   
  
 



    <strong>       </strong>
    <p>       </p>
    <input class="button1"  onclick="
    selectElementContents( 
    document.getElementById('sig1-') );" 
    value="copy">
    
    <table1 id=sig1->
    <tr><td>        
 <pre1>
    
    
 </pre1>
    </td></tr>
    </table1>   














  
     <strong>       </strong>
     <p>       </p>
     <input class="button1"  onclick="
     selectElementContents( 
     document.getElementById('sig1-') );" 
     value="copy">
     
     <table1 id=sig1->
     <tr><td>        
     <pre1>
     
     
     </pre1>
     </td></tr>
     </table1>   







   
   
   
   
   </body>
  
  
  
  </html>
 
       